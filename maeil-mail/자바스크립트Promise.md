Promise는 <strong>비동기 작업을 관리하고, 해당 작업의 성공 또는 실패 결과를 나중에 사용할 수 있도록 하는 객체</strong>다.
Promise는 비동기 작업의 완료 여부를 약속해주는 개념이다.

자바스크립트는 <strong>비동기 처리를 위한 콜백 함수</strong>를 많이 사용한다. 하지만 콜백 함수는 코드가 복잡해지면서 <strong>콜백 지옥</strong>문제를 야기할 수 있다. Promise는 이러한 비동기 처리의 가독성을 높이고, 코드의 흐름을 명확하게 관리할 수 있도록 도와주는 방식이다.

Promise는 3가지 상태를 가진다.
1. 비동기 작업이 완료되지 않은 초기 상태를 나타내는 Pending
2. 비동기 작업이 성공적으로 완료되어 값을 반환한 상태인 Fulfilled
3. 비동기 작업이 실패하여 오류를 반환한 상태인 Rejected

이 세가지 상태 중 하나로 전환되면, 이후에는 다른 상태로 전환되지 않으며, Fulfilled나 Rejected 상태가 되면 결과 값을 통해 해당 작업의 성공 여부를 알 수 있다.

또한 Promise 객체는 비동기 작업을 수행할 함수를 인자로 받아서 실행하며, 이 함수는 resolve와 reject라는 두 가지 콜백을 받는다.

resolove는 비동기 작업이 성공했을 때 값을 전달하여 Promise를 fulfilled 상태로 전환하고, reject는 비동기 작업이 실패했을 때 오류를 전달해 Promise를 rejected 상태로 전환한다.

또한 try-catch-finally 구조로 비동기 작업의 실패와 에러, 또 마지막 부분에 대한 처리를 명시적으로 나타내줄 수 있다.

Promise는 <strong>코드의 가독성을 높이고, 비동기 작업의 흐름을 제어</strong>하는 데 매우 유용하다.
여러 개의 Promise를 순차적으로 연결할 수도 있고, Promise.all이나 allSettled 같은 메서드를 통해 병렬로 비동기 작업을 처리해볼 수도 있다.

*Promise 단점
1. 복잡한 에러 처리
* 단일 체인에서는 에러 처리가 간단하지만, 여러 Promise가 중첩되거나 서로 다른 비동기 흐름에서 에러가 발생할 경우 복잡도가 증가할 수 있다. then 체인 내의 중간 단계에서 오류가 발생하면 catch 블록에서 캐치할 수 있지만, 특정 단계에서만 발생하는 에러를 세밀하게 다루기 어렵다. 따라서 비동기 흐름에서 발생하는 다양한 에러를 모두 처리하려면 코드가 복잡해진다.

2. 콜백 지옥을 완전히 해결하지는 못한다.
비동기 작업이 복잡하게 중첩되면 콜백과 유사하게 여러 then 메서드가 연속해서 사용되며 가독성이 떨어질 수 있다.
여러 Promise를 순차적으로 실행해야 할 때 then 체인을 계속 사용하면 코드의 들여쓰기 구조가 복잡해지고 이해하기 어려워지는 문제점이 있다. 이는 async/await을 통해 개선할 수 있다.
